/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Other/File.java to edit this template
 */

package GraphProblemsPartII;

import java.util.Arrays;

/**
 *Date: 05/22/2024
 * https://leetcode.com/problems/minimize-malware-spread/
 * @author parth
 */
public class MinimizeMalwareSpreadDSU {
    
    public static int[] parent; // Array to store the parent of each node
    public static int[] size; // Array to store the size of each component

    /**
     * Main function to find the node to remove to minimize malware spread
     * @param graph The graph representing the network connectivity
     * @param initial The initial set of infected nodes
     * @return The node to remove to minimize malware spread
     */
    public static int minMalwareSpread(int[][] graph, int[] initial){
        // Initialize the arrays for DSU
        parent = new int[graph.length];
        size = new int[graph.length];

        // Initialize parent and size arrays
        for(int i = 0; i < graph.length;i++){
            parent[i] = i;
            size[i] = 1;
        }
        
        // Union operation based on graph connectivity
        for(int i = 0; i < graph.length;i++){
            for(int j = 0; j < graph[i].length;j++){
                if(graph[i][j] == 1){  // Two vertices are connected
                    // Union the components
                     int p1 = find(i);
                     int p2 = find(j);

                     if(p1 != p2){
                        union(p1,p2);
                     }
                }
            }
        }
        
        // Count infected nodes in each component
        int[] infected = new int[graph.length];
        //The array infected is automatically initialized with 0's
        //Infected array tells you in a particular group how many nodes are infected 
        for(int i : initial){
            int p = find(i);
            infected[p]++;
        }
        System.out.println(Arrays.toString(infected));
        // Find the node to remove to minimize malware spread
        int answer = -1;
        int maxSize = -1;
        for(int i : initial){
            int p = find(i);
            
            if(infected[p] == 1 && size[p] >= maxSize){
                //We write infected[p] == 1 because if its 0 that means no node in the component was infected 
                //but if its greater than 1 that means multiple nodes in component were infected hence removing one of them 
                //wont help as the other one might infect the same component 
                //so we need to check if only one node has been infected or not
                if(maxSize == size[p]){
                    answer = Math.min(answer,i);
                }else{
                    answer = i;
                }
                
                maxSize = size[p]; //update the maxSize
            }
        }
        
        // If no node to remove is found, return the smallest index among the initial infected nodes
        if(answer == -1){
           int min = Integer.MAX_VALUE; 
           for(int i : initial){
               min = Math.min(i, min);
           }
           return min;
        }
        
        return answer;
    }
    
    // Union operation for DSU
    public static void union(int lx, int ly){
        if(size[lx] > size[ly]){
            parent[ly] = lx;
            size[lx] = size[lx] + size[ly];
        }else{
            parent[lx] = ly;
            size[ly] = size[ly] + size[lx];
        }
    }
    
    // Find operation for DSU with path compression
    public static int find(int x){
        if(parent[x] == x){
            return x;
        }
        int temp = find(parent[x]);
        parent[x] = temp; // Path compression
        return temp;
    }
}
