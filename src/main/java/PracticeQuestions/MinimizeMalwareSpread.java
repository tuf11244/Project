/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Other/File.java to edit this template
 */
package PracticeQuestions;
import java.util.*;
/**
 *Date: 05/18/2024
 * https://leetcode.com/problems/minimize-malware-spread/
 * Did this question by myself 
 * 05/19/2024 at 1:11AM
 * LeetCode submitted 8 times 
 * @author parth
 */
public class MinimizeMalwareSpread {

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        int[][] matrix = {
            {1,1,0},
            {1,1,0},
            {0,0,1}
        
        };
        int[] initial = {0,1};
        
        minimizeMalwareSpread(matrix,initial);
    }
    public static void minimizeMalwareSpread(int[][] matrix, int[] initial){
        //Note that matrix.length = is the number of vertices 
        List<Edge> [] graph = new ArrayList[matrix.length];
        
        for(int i = 0; i < matrix.length;i++){
            graph[i] = new ArrayList<>();
        }
        
        //Build the graph
        for(int i = 0; i < matrix.length;i++){
            for(int j = 0; j < matrix[i].length;j++){
                if(matrix[i][j] == 1){ //that means its connected
                    graph[i].add(new Edge(i,j));
                    graph[j].add(new Edge(j,i));
                }
            }
        }
        
        //Get the connected components
        boolean visited[] = new boolean[matrix.length];
        List<List<Integer>> connectedComp = new ArrayList<>();
        for(int i = 0; i < initial.length;i++){
             if(visited[initial[i]] == false){
                 List<Integer> temp = new ArrayList<>();
                 dfs(visited,graph,temp,initial[i]);//fill up our temp arraylist 
                 connectedComp.add(temp);
             }
        }
        
        //Now from our connectedComp list find the actual number of nodes infected without duplicated 
        HashSet<Integer> set = new HashSet<>();
        for(List<Integer> list : connectedComp){
            for(int node : list){
                set.add(node);
            }
        }
        System.out.println(set);
        
        //Create a HashMap 
        //The key is intial[i] the given infected node 
        //The value is the connected component that key brings 
        HashMap<Integer,List<Integer>> hm = new HashMap<>();
        //Reset the visited array 
        visited = new boolean[matrix.length];
        
        for(int i = 0; i < initial.length;i++){
            //Remove the the elements one by one 
             List<Integer> temp = new ArrayList<>();
             dfs(visited,graph,temp,initial[i]);
             hm.put(initial[i], temp);
             visited = new boolean[matrix.length]; //Reset the visited array
        }
        
       System.out.println(hm);
        
       int ans1 = Integer.MAX_VALUE;
       int ans2 = Integer.MAX_VALUE;
       
       int minSize = Integer.MAX_VALUE;
       List<Integer> minNodeValue = new ArrayList<>();
       
       List<Integer> keys = new ArrayList<>(hm.keySet()); //// Collect keys in a separate list
       //otherwise directly iterating over the hm.keySet() would give concurrentModification error
       
       for(int value : keys){
           List<Integer> duplicateList = hm.get(value); //get the list
           int duplicateValue = value;  //store the value 
           hm.remove(value); //delete the value 
           
            Set<Integer> tempSet = new HashSet<>();
           for(int v : hm.keySet()){
               List<Integer> vList = hm.get(v);
               
               for(int x : vList){
                   tempSet.add(x);
               }
               
           }
           if(tempSet.size() == set.size()){
               ans2 = Math.min(ans2, duplicateValue); //because we need the minimum node value
           
           }
           else if(tempSet.size() < set.size()){
               //Get the min Size 
               //This case will always take priority over the above case
               
               minSize = Math.min(tempSet.size(), minSize); //min size of the tempSet.size() 
               minNodeValue.add(duplicateValue); //add the duplicate value to our list 
           }
           
           //put the value back in our hm
           hm.put(duplicateValue,duplicateList);
           
           
       }
       
       for(int value : hm.keySet()){
          List<Integer> list = hm.get(value);
          //minNodeValue should contain the value for it be one the possible ans
          if(set.size() - minSize == list.size() && minNodeValue.contains(value)){
              ans1 = Math.min(ans1, value);
          }
       }
       
       if(ans1 != Integer.MAX_VALUE){
           System.out.println("The min Node is " + ans1);
       }else{
           System.out.println("The min Node is " + ans2);
       }
       
    }
    
    public static void dfs(boolean[] visited, List<Edge> [] graph, List<Integer> temp, int src){
        visited[src] = true;
        temp.add(src);
        for(Edge e : graph[src]){
            if(visited[e.nbg] == false){
                dfs(visited,graph,temp,e.nbg);
            }
        }
        
       
    }
}

class Edge{
    int src;
    int nbg;
    
    public Edge(int src, int nbg){
        this.src = src;
        this.nbg = nbg;
    }
}
