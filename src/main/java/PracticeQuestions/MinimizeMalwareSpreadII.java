package PracticeQuestions;
import java.util.*; // Importing necessary packages

/**
 * Date: 05/22/2024
 * https://leetcode.com/problems/minimize-malware-spread-ii/
 * @author parth
 */
public class MinimizeMalwareSpreadII {

    // Arrays to support Disjoint Set Union (DSU) operations
    public static int[] parent; // Array to store the parent of each node in the DSU
    public static int[] size; // Array to store the size of each component in the DSU

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        // Entry point of the program, typically used for testing
    }

    public static int minMalwareSpread(int[][] graph, int[] initial) {
        // Initialize the DSU arrays
        parent = new int[graph.length];
        size = new int[graph.length];

        // Each node is its own parent initially and size is 1
        for(int i = 0; i < graph.length; i++) {
            parent[i] = i;
            size[i] = 1;
        }
        
        // Create a set of all initially infected nodes
        HashSet<Integer> set = new HashSet<>();
        for(int i = 0; i < initial.length; i++) {
            set.add(initial[i]);
        }
        
        // Perform union operations based on graph connectivity
        for(int i = 0; i < graph.length; i++) {
            for(int j = 0; j < graph[i].length; j++) {
                // Union nodes that are connected and not infected
                if(graph[i][j] == 1 && !set.contains(i) && !set.contains(j)) {
                    int p1 = find(i); // Find the root of node i
                    int p2 = find(j); // Find the root of node j
                    if(p1 != p2) {
                        union(p1, p2); // Union the components
                    }
                }
            }
        }
        
        // Map to store which components each infected node can influence
        HashMap<Integer, HashSet<Integer>> hm = new HashMap<>();
        // Array to count the number of infections in each component
        int[] infected = new int[graph.length];
        
        // Populate the hashmap with the influenced components for each infected node
        for(int i : initial) {
            hm.put(i, new HashSet<>());
            for(int j = 0; j < graph.length; j++) {
                if(graph[i][j] == 1 && i != j && !set.contains(j)) {
                    int p = find(j); // Find the root of node j
                    if(!hm.get(i).contains(p)) {
                        hm.get(i).add(p); // Add the component to the set of influenced components
                        infected[p]++; // Increment the infection count of the component
                    }
                }
            }
        }
        
        int answer = -1; // Variable to store the node to be removed
        int max = -1; // Variable to store the maximum size of the unique components

        // Determine which infected node's removal minimizes the malware spread the most
        for(int i : initial) {
            HashSet<Integer> parents = hm.get(i); // Get the set of influenced components
            int total = 0;
            for(int p : parents) {
                if(infected[p] == 1) { // Count only the unique components
                    total += size[p]; // Sum up the sizes of the unique components
                }
            }

            // Update the answer if the current node leads to a better result
            if(total >= max) {
                if(total == max) {
                    answer = Math.min(answer, i); // Choose the smallest index in case of a tie
                } else {
                    answer = i; // Choose the current node if it leads to a larger component
                }
                max = total; // Update the maximum size
            }
        }

        // If no node to remove is found, return the smallest index among the initial infected nodes
        if(answer == -1) {
            int min = Integer.MAX_VALUE; 
            for(int i : initial) {
                min = Math.min(i, min);
            }
            return min;
        }
        
        return answer; // Return the node to be removed
    }
    
    // Union operation for DSU
    public static void union(int lx, int ly) {
        // Union by size: attach the smaller tree under the larger tree
        if(size[lx] > size[ly]) {
            parent[ly] = lx;
            size[lx] += size[ly];
        } else {
            parent[lx] = ly;
            size[ly] += size[lx];
        }
    }
    
    // Find operation for DSU with path compression
    public static int find(int x) {
        if(parent[x] == x) {
            return x; // Return the root if x is the root
        }
        int temp = find(parent[x]); // Recursively find the root
        parent[x] = temp; // Path compression: directly connect x to the root
        return temp;
    }
}
